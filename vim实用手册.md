# 技巧一  精确移动+.(重复命令)
## 精确移动 一行的内容
f F ; ,
单词的移动 /word n N ?word n N ```html <a href="#">nihao</a> = you <a href = "#">nihao</a> = you <a href = "#">nihao</a> = you
	<a href="#">nihao</a>=you
	<a href="#">three</a>=you
```
如何吧这=前后加上空格使得跟美观 
f= 在该行中找到= 
s =  输入想要的内容
; 移动到下一个=精确移动
. 重复之前的命令
很多都可使用的技巧如层次缩进等 

理想状态就是 一个移动一个重复

# 技巧二
## 插入模式下的技巧
<ctrl> + r + 寄存器的名称  不离开插入模式的情况下 插入寄存器中的文本
<ctrl> + r + <c-p> + 寄存器的名称   这个可以更加智能的输出文本 会去除不必要的缩进

插入模式下编辑文本  
<ctrl> + w  删除之前的一个单词
<ctrl> + h  删除之前的一个字符
<ctrl> + u  删除该行

# 不常用字符的添加
<c-v> {number编码}  
具体见 :h digraph-table

## 可视模式

选中区域的技巧
vit 
viw
vi)/(
vi[/]
都可以 选中括号中的内容

gv 重新选择上次执行的区域
o  切换选区的活动端
可以对选中区域进行命令 >< 缩进 r  y  c  d gu和gU 变换大小写

# 命令行

都d t(copy的简写) p c m j(连接指定范围内的行)
```
| 命令                                           | 含义                                        |
|------------------------------------------------|---------------------------------------------|
| :[range] yank [x]                              | 删除指定范围内的行到寄存器中去              |
| :[range] delect [x]                            | 复制指定范围内的行到指定寄存器中区          |
| :[line] put [x]                                | 在指定行后粘贴寄存器x的内容                 |
| :[range] copy { address }                      | 把指定范围的行复制到 address指定的行之下    |
| :[range] move { address }                      | ..............移动....                      |
| :[range] join                                  | 连接指定范围内的行                          |
| :[range] normal {commands}                     | 对指定范围内的每一行执行普通模式下的命令    |
| :[range] substituute/{pattern}/{string}/[flag] | 替换                                        |
| :[range] global/{pattern}/[cmd]                | 对指定范围内匹配patter的所有行执行EX命令cmd |
```

在 一行或者多个连续的行执行命令
```md
	.
	$
	0
	`m
	%s 
	.+number
```

@: 重复执行上次的ex 命令
# 多窗口管理

<c-w>s 水平切割
<c-w>v 竖直切割
:sp {file}
:vsp {file}
:bd 关闭一个buffer 被我设置成了,d

# 打开和保存文件
解决打开时候没有加sudo 导致没办法保存
:w !sudo tee % >/dev/null

# 跳转技巧
屏幕行的上下移动而不是实际行
gj 
gk
屏幕行的末端和前段
g0 
g$

f F t T 区别 就是t是移动到字符的前一个字符
; , 下一个和上一个

a) i)
a[ i]
a' i'
a" i"
at it 
区别是 i不包含外面扩住的东西  a包含它
iw aw
iW aW 当前字串   i和a的区别是包不包含一个空格
is as 当前句子
ip ap 当前段落 一空行来区分

'' 上次跳转的位置之前
'. 上次修改的位置
'['] 上次修改或复制的开始和结束位置
'<'> 上次高亮选区的开始和结束位置

ma  'a 标记位置  和跳转位置   

括号之间的跳转  %  
#  文件中的跳转
<c-i> 和<c-o> 就就击落我们编辑会话中访问过的文件 进行跳转
# 复制和粘贴

复制专用寄存器 0
1-9 之前的内容保存
a-z 用户可以自定义
+ 系统剪切版上的
* 选择专用寄存器

= 表达式寄存器
% 当前文件名
: 上次的ex命令
/上次查找的内容

使用也很简单
"{寄存器名称}y 
"{寄存器}p
插入模式下粘贴寄存器的内容 <c-r>

yap 这个可以空行区分一块内容  进行复制


:set paste 可以解决缩进的问题

# 宏
q+字母开始 +q 结束   
数值@+字母使用

不用太在意数值 宏执行出错就会自动停止

并行执行的方式就是选中要执行的文本
'<,'>normal @a 

```
class Animal
	#implementation
end

把上面的三行转化为下面的几列

module Rank
	class Animal
		#implementation
	end
end

```

| 命令              | 效果            |
|-------------------|-----------------|
| qa                | 开始            |
| gg/class<CR>      | 查找class并跳转 |
| Omodule Rank<esc> | 添加内容        |
| j>2j              | 进行缩进        |
| end<esc>          | 插入内容        |
| q                 | 结束录制        |

显示宏 就是 :reg a
让宏输出到界面 中就是:put a
将改变后的宏导入到a中就是 "add

# 查找
\v\V 按照原义查找

# 替换
 
用寄存器中的内容替换
:%s//<c-r>0/g 就是用0 寄存器中的内容进行替换

#global命令


